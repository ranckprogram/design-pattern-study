# 创建型设计模式

> SOLID 设计模式遵循的设计原则

- 单一职责
- 开闭原则
- 里氏替换原则
- 接口隔离原则
- 依赖倒置原则



- 工厂模式
- 抽象工厂模式
- 建造者模式
- 原型模式
- 单例模式


### 工厂模式

**定义：**

生产出具有某些标准接口特性的产品

**组成：**

- 工厂接口
- N 个基于工厂接口的工厂类
- 工厂函数
- 客户端

**原则:**

- 开闭原则

闭合：客户端的调用方式不变
开放：1. 通过实现工厂接口 2. 变更工厂函数配置进行拓展

- 单一职责原则

每一个具体的工厂类，只负责处理自己本身的业务逻辑

**用途：**

**实现步骤：**

1. 定义统一的工厂类接口，约定特定方法
2. 根据接口实现不同的 N 个类
3. 定义工厂方法

**业务场景：**

对产品类型的拓展，不影响到以前的产品。

### 抽象工厂模式

**定义：**

工厂的工厂

可以创建一系列相同特性风格的工厂

**组成：**

**原则:**

**用途：**
产品族稳定
产品风格拓展
**实现步骤：**

**业务场景：**

前端组件库，不同风格；
重构时候会更多考虑这个方面的使用
如果本身产品族会增加，使用这个模式就会很大面积的代码变动

### 建造者模式

**定义：**
分步骤建造复杂对象

**组成：**

- 目标对象容器 Builder

  - setMethod[]
  - build 最终返回对象

- 客户端
  - 使用所需 setMethod
  - 调用 build 得到实例

**原则:**

**用途：**

创建复杂对象，对象的组成自由组合，组合主动权交给用户

**实现步骤：**

- 定义 Builder 对象

**业务场景：**

- 订单
- 套餐生成
- 配置参数来自于不同的接口服务
- 异步调用

### 单例模式

**定义：**

确保一个类创建出的实例只有一个

- 懒汉模式
- 饿汉模式

**组成：**

- 目标类，类中保函静态方法，判断 instance

**原则:**

**用途：**

按特定规则生成全局唯一序列号

**实现步骤：**

_懒汉模式_, 用的时候自己调静态方法

```javascript
class Singlon {
  static getInstance() {
    if (!this.instance) {
      this.instance = new Singlon();
    }
    return this.instance;
  }
}
```

_饿汉模式_,载入时候就处理

```javascript
var instance = (function () {
  class Singlon {}
  return new Singlon();
})();
```

**业务场景：**

### 原型模式

**定义：**

用于克隆方式创建重复对象，不依赖原有的类，保证性能

_如果目标对象的创建过程比较消耗性能，用原型可以减少过程消耗_


java中的克隆很靠近底层。性能会很好

**组成：**

**原则:**

**用途：**

**实现步骤：**

深度克隆

```javascript
function deepClone(obj) {
  if (typeof obj === null) {
    return null;
  }
  if (Array.isArray(obj)) {
    return;
  }
  if (typeof obj === "object") {
    for (let item in obj) {
    }
  }

  return;
}
```

**业务场景：**
